## Algorithm patterns 

#### 1. Prefix Sum (Префиксные суммы)

Префиксные суммы — это фундаментальный алгоритмический паттерн, позволяющий эффективно отвечать на запросы суммы элементов массива на произвольном подотрезке.

##### Что такое префиксные суммы?

Пусть есть массив  
$$a = [a_0, a_1, ..., a_{n-1}]$$.  
Префиксные суммы — это массив $$s$$ длиной $$n+1$$, где

$$
s_0 = 0, \quad s_k = a_0 + a_1 + \ldots + a_{k-1} \quad \text{для } k=1..n
$$

То есть $$s_k$$ — сумма первых $$k$$ элементов исходного массива (не включая $$a_k$$).

Префиксные суммы можно вычислить за линейное время одним проходом:

```go
s = 0
for i := 0; i < n; i++ {
s[i+1] = s[i] + a[i]
}
```

### Какие задачи решает паттерн?

Основная задача — быстро отвечать на запросы вида: найти сумму элементов массива на полуинтервале $$[l, r)$$. Без префиксных сумм на каждый запрос пришлось бы суммировать элементы заново, что в худшем случае — $$O(n)$$.

С префиксными суммами ответ на запрос находится за $$O(1)$$:

$$
\text{сумма}(l, r) = s_r - s_l
$$

Это работает, потому что $$s_r$$ — сумма первых $$r$$ элементов, а $$s_l$$ — сумма первых $$l$$ элементов, вычитая их, получаем сумму элементов с $$l$$-го по $$r-1$$-й.

### Преимущества

- **Быстрые запросы:** после предподсчёта массива префиксных сумм можно отвечать на запросы суммы за константное время.
- **Простота реализации:** алгоритм очень простой и понятный.
- **Широкое применение:** используется во многих задачах, связанных с подсчётом сумм, подсчётом количества элементов, подсчётом частот, а также в более сложных структурах данных.

### Популярные задачи на LeetCode с использованием префиксных сумм

- **303. Range Sum Query - Immutable** — классическая задача, где нужно быстро отвечать на запросы суммы подмассива.
- **560. Subarray Sum Equals K** — нахождение количества подмассивов с суммой, равной $$k$$, где префиксные суммы помогают вычислять суммы подмассивов и использовать хеш-таблицу для ускорения.
- **724. Find Pivot Index** — поиск индекса, где сумма слева равна сумме справа, удобно вычислять через префиксные суммы.
- **525. Contiguous Array** — задача на поиск подмассива с равным количеством 0 и 1, где префиксные суммы модифицируются для подсчёта баланса.
- **1480. Running Sum of 1d Array** — простой пример вычисления кумулятивной суммы.

### Итог

Префиксные суммы — это мощный и простой паттерн, который позволяет:

- предподсчитать накопленные суммы массива за $$O(n)$$,
- отвечать на запросы суммы подотрезков за $$O(1)$$,
- значительно оптимизировать задачи с множеством запросов сумм.

Этот паттерн часто является отправной точкой для решения более сложных задач на интервалы, частотные запросы и динамическое программирование.

##### 2. Two Pointers (Два указателя)

Паттерн "Два указателя" — это алгоритмическая техника, в которой два указателя (индекса) итеративно проходят по структуре данных (обычно массиву или строке), двигаясь навстречу друг другу или в одном направлении, пока не будет достигнуто определённое условие.

Идея в том, чтобы эффективно обрабатывать пары элементов или подмассивы, избегая излишних повторных проходов и снижая временную сложность.

##### Какие проблемы решает?

- Поиск пары элементов с заданной суммой в отсортированном массиве.
- Нахождение подмассивов с определёнными свойствами (например, с суммой, не превышающей заданного значения).
- Слияние отсортированных массивов.
- Проверка палиндрома в строке.
- Поиск минимального/максимального окна с заданными условиями.
- Оптимизация перебора пар, тройок и т.д. элементов.

##### Как работает метод?

Рассмотрим классический пример — поиск двух чисел в отсортированном массиве, сумма которых равна заданному числу `X`.


Массив: `[1, 2, 3, 4, 5]`, `X = 7`

- Устанавливаем два указателя: `left = 0` (начало массива), `right = len(array)-1` (конец массива)
- Пока `left < right`:
  - Считаем сумму: `sum = array[left] + array[right]`
  - Если `sum == X`, нашли ответ
  - Если `sum < X`, сдвигаем `left` вправо (увеличиваем сумму)
  - Если `sum > X`, сдвигаем `right` влево (уменьшаем сумму)
- Если указатели пересеклись — ответ не найден

Так как каждый элемент обрабатывается максимум один раз, итоговая сложность — `O(n)` вместо `O(n^2)` при переборе всех пар.


##### Популярные задачи на LeetCode с паттерном "Два указателя"

- [1. Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)  
  Классическая задача поиска пары с заданной суммой в отсортированном массиве.

- [15. 3Sum](https://leetcode.com/problems/3sum/)  
  Поиск всех уникальных триплетов, сумма которых равна нулю. Использует вложенный цикл и два указателя.

- [125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)  
  Проверка, является ли строка палиндромом, с помощью двух указателей, двигающихся навстречу друг другу.

- [344. Reverse String](https://leetcode.com/problems/reverse-string/)  
  Разворот строки на месте с помощью двух указателей.

- [524. Longest Word in Dictionary through Deleting](https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/)  
  Использование двух указателей для проверки, можно ли получить слово из другой строки путём удаления символов.



##### Когда использовать паттерн "Два указателя"?

- Когда данные отсортированы или могут быть обработаны в отсортированном виде.
- Когда нужно искать пары, подмассивы или подстроки с определёнными свойствами.
- Когда требуется оптимизировать перебор пар элементов с линейной сложностью.



##### Отличие от паттерна "Быстрый и медленный указатели"

- В "Двух указателях" оба указателя обычно двигаются независимо, часто навстречу друг другу.
- В "Быстром и медленном" один указатель движется быстрее другого (например, в задачах с циклами в связных списках).

##### Итог

Паттерн "Два указателя" — простой и мощный инструмент для оптимизации задач, связанных с поиском пар, подмассивов и подстрок. Он позволяет снизить сложность с квадратичной до линейной и широко применяется в интервью и реальных задачах.

##### 3. Sliding Window (Скользящее окно)

Конечно, вот подробный разбор паттерна "Скользящее окно" в формате Markdown.

# Паттерн "Скользящее окно" (Sliding Window)

## Что это за паттерн?

**Скользящее окно** — это алгоритмическая техника, которая применяется к линейным структурам данных, таким как массивы или строки. Паттерн представляет собой воображаемое "окно" (непрерывный подмассив или подстроку), которое "скользит" по данным. Это окно определяется двумя указателями — `left` (левая граница) и `right` (правая граница).

Основная идея заключается в том, чтобы избежать повторных вычислений, которые возникают при использовании вложенных циклов (например, при переборе всех возможных подмассивов). Вместо того чтобы пересчитывать значение для каждого нового подмассива с нуля, мы эффективно обновляем результат, добавляя новый элемент справа и удаляя старый элемент слева.

## Ключевая идея

1.  **Расширение окна**: Указатель `right` всегда движется вправо, расширяя окно.
2.  **Сужение окна**: Указатель `left` движется вправо (но только при выполнении определенного условия), сужая окно.

Это позволяет за один проход по массиву (сложность O(n)) обработать все интересующие нас подмассивы.

## Типы "Скользящего окна"

### 1. Окно фиксированного размера (Fixed-Size Window)
Размер окна `k` известен заранее и не меняется. Окно просто сдвигается на один элемент вправо на каждой итерации.

**Пример логики:**
```python
# Найти максимальную сумму подмассива размером k
k = 3
current_sum = sum(nums[0:k])
max_sum = current_sum

for i in range(k, len(nums)):
    # "Сдвигаем" окно: добавляем новый элемент и удаляем старый
    current_sum += nums[i] - nums[i-k]
    max_sum = max(max_sum, current_sum)
```

### 2. Окно динамического размера (Dynamic-Size Window)
Размер окна меняется в зависимости от условий задачи. Обычно окно расширяется до тех пор, пока не нарушится какое-либо условие, после чего оно начинает сужаться с левой стороны до тех пор, пока условие снова не будет выполнено.

**Пример логики:**
```python
# Найти самый короткий подмассив, сумма которого >= target
left = 0
current_sum = 0
min_length = float('inf')

for right in range(len(nums)):
    current_sum += nums[right]
    
    # Пока условие выполнено (сумма >= target), сужаем окно слева
    while current_sum >= target:
        min_length = min(min_length, right - left + 1)
        current_sum -= nums[left]
        left += 1
```

## Какие проблемы решает?

Паттерн идеально подходит для задач, где нужно найти **непрерывный** подмассив или подстроку, которые удовлетворяют определенным ограничениям.

*   Поиск самого длинного/короткого подмассива/подстроки.
*   Поиск подмассива с максимальной/минимальной суммой/произведением.
*   Поиск подстрок, являющихся анаграммами/пермутациями другой строки.
*   Подсчет количества подмассивов, удовлетворяющих условию.

## Преимущества

*   **Оптимизация времени**: Снижает временную сложность с O(n²) или O(n*k) до **O(n)**, так как каждый элемент массива посещается указателями `left` и `right` не более одного раза.
*   **Оптимизация памяти**: Обычно требует **O(1)** или **O(k)** дополнительной памяти (где `k` — размер алфавита или фиксированного окна), что гораздо эффективнее создания и хранения всех подмассивов.

## Шаблон реализации (для окна динамического размера)

Этот шаблон является основой для решения большинства задач на динамическое окно.

```python
def sliding_window_template(arr, ...):
    left = 0
    result = ...  # Инициализация результата (0, float('inf'), и т.д.)
    # Структура для хранения состояния окна (например, hash_map, current_sum)
    window_state = ...

    for right in range(len(arr)):
        # 1. Расширяем окно: добавляем arr[right] в наше состояние
        add_to_window(arr[right], window_state)

        # 2. Сужаем окно: пока условие для сужения выполняется...
        while condition_to_shrink(window_state):
            # ...удаляем arr[left] из состояния...
            remove_from_window(arr[left], window_state)
            # ...и сдвигаем левую границу.
            left += 1

        # 3. Обновляем результат: после сужения окно снова валидно.
        #    Здесь мы можем обновить глобальный результат.
        update_result(result, window_state)

    return result
```

## Популярные задачи на LeetCode

### 1. Longest Substring Without Repeating Characters (LeetCode 3)
**Тип:** Динамическое окно.
**Задача:** Найти длину самой длинной подстроки без повторяющихся символов.

```python
def lengthOfLongestSubstring(s: str) -> int:
    char_set = set()
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        # Если символ уже в окне, сужаем окно слева
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        
        # Добавляем новый символ в окно
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)
        
    return max_length
```

### 2. Minimum Size Subarray Sum (LeetCode 209)
**Тип:** Динамическое окно.
**Задача:** Найти минимальную длину непрерывного подмассива, сумма которого больше или равна `target`.

```python
def minSubArrayLen(target: int, nums: list[int]) -> int:
    left = 0
    current_sum = 0
    min_length = float('inf')
    
    for right in range(len(nums)):
        current_sum += nums[right]
        
        # Как только сумма достигла цели, пытаемся сократить окно слева
        while current_sum >= target:
            min_length = min(min_length, right - left + 1)
            current_sum -= nums[left]
            left += 1
            
    return min_length if min_length != float('inf') else 0
```

### 3. Find All Anagrams in a String (LeetCode 438)
**Тип:** Окно фиксированного размера.
**Задача:** Найти все начальные индексы анаграмм строки `p` в строке `s`.

```python
from collections import Counter

def findAnagrams(s: str, p: str) -> list[int]:
    if len(s) < len(p):
        return []
        
    p_counter = Counter(p)
    s_counter = Counter()
    result = []
    
    for i in range(len(s)):
        # Добавляем правый символ в окно
        s_counter[s[i]] += 1
        
        # Если окно стало больше нужного, удаляем левый символ
        if i >= len(p):
            if s_counter[s[i - len(p)]] == 1:
                del s_counter[s[i - len(p)]]
            else:
                s_counter[s[i - len(p)]] -= 1
        
        # Если окно достигло нужного размера и счетчики равны
        if i >= len(p) - 1:
            if s_counter == p_counter:
                result.append(i - len(p) + 1)
                
    return result
```

### 4. Minimum Window Substring (LeetCode 76)
**Тип:** Динамическое окно (сложная версия).
**Задача:** Найти минимальное окно в строке `s`, которое содержит все символы из строки `t`.

```python
from collections import Counter

def minWindow(s: str, t: str) -> str:
    if not t or not s:
        return ""

    dict_t = Counter(t)
    required = len(dict_t)
    
    left = 0
    formed = 0
    window_counts = {}
    
    ans = float("inf"), None, None # (длина, левый, правый)

    for right, char in enumerate(s):
        window_counts[char] = window_counts.get(char, 0) + 1
        
        if char in dict_t and window_counts[char] == dict_t[char]:
            formed += 1
        
        while left <= right and formed == required:
            # Обновляем результат
            if right - left + 1 < ans[0]:
                ans = (right - left + 1, left, right)
            
            # Сужаем окно
            left_char = s[left]
            window_counts[left_char] -= 1
            if left_char in dict_t and window_counts[left_char] < dict_t[left_char]:
                formed -= 1
            
            left += 1

    return "" if ans[0] == float("inf") else s[ans[1] : ans[2] + 1]
```

### Другие популярные задачи

*   **LeetCode 567**: Permutation in String (аналогично анаграммам, окно фиксированного размера)
*   **LeetCode 424**: Longest Repeating Character Replacement (динамическое окно)
*   **LeetCode 643**: Maximum Average Subarray I (простейшее окно фиксированного размера)
*   **LeetCode 1004**: Max Consecutive Ones III (динамическое окно)

## Когда использовать "Скользящее окно"? (Сигналы)

Ищите этот паттерн, если в условии задачи есть следующие признаки:

*   **Входные данные**: Массив, строка или связанный список.
*   **Задача**: Найти **непрерывный** подмассив или подстроку.
*   **Цель**: Найти `максимум`, `минимум`, `самый длинный`, `самый короткий` или `количество` подмассивов, удовлетворяющих условию.
*   **Ключевые слова**: "подмассив", "подстрока", "непрерывный".

Если вы видите эти сигналы, попробуйте сначала придумать решение с двумя вложенными циклами (O(n²)), а затем подумайте, как его можно оптимизировать до O(n) с помощью скользящего окна.

##### 4. Fast and Slow Pointers (Быстрый и медленный указатели)

##### 5. Linked List In-place Reversal (Обратный порядок связного списка на месте)

##### 6. Monotonic Stack (Монотонный стек)

Конечно! Вот подробное объяснение паттерна "Монотонный стек" в формате Markdown.

---

## Монотонный стек (Monotonic Stack)

### Что это такое?

**Монотонный стек** — это структура данных, основанная на обычном стеке, но с одним дополнительным свойством: элементы в стеке всегда упорядочены (либо по возрастанию, либо по убыванию).

Существует два типа монотонных стеков:

1.  **Монотонно возрастающий стек (Increasing Stack)**: Элементы в стеке всегда расположены в порядке возрастания от дна к вершине (`stack[0] < stack[1] < ... < stack[top]`).
2.  **Монотонно убывающий стек (Decreasing Stack)**: Элементы в стеке всегда расположены в порядке убывания от дна к вершине (`stack[0] > stack[1] > ... > stack[top]`).

Это свойство поддерживается специальным образом при добавлении новых элементов. Если новый элемент нарушает монотонность, элементы с вершины стека удаляются до тех пор, пока свойство не будет восстановлено.

### Как это работает?

Основная идея заключается в том, что при обработке каждого элемента массива мы используем стек для отслеживания элементов, для которых мы еще не нашли ответ.

Рассмотрим на примере **поиска следующего большего элемента (Next Greater Element)**. Для этого нам понадобится **монотонно убывающий стек**. В стеке мы будем хранить **индексы**, а не сами значения, что является стандартной практикой.

Пусть у нас есть массив `nums = [2, 1, 5, 6, 2, 3]`.

1.  **Инициализация**: `stack = []`, `result = [-1, -1, -1, -1, -1, -1]` (массив для ответов).

2.  **Итерация по `nums` (i = 0, val = 2)**:
    *   Стек пуст. Добавляем индекс `0`.
    *   `stack = [0]` (значение `nums[0]`=2)

3.  **Итерация по `nums` (i = 1, val = 1)**:
    *   Смотрим на вершину стека: `stack[-1] = 0`. `nums[1]` (1) < `nums[0]` (2). Монотонность (убывание) не нарушена.
    *   Добавляем индекс `1`.
    *   `stack = [0, 1]` (значения `[2, 1]`)

4.  **Итерация по `nums` (i = 2, val = 5)**:
    *   Смотрим на вершину стека: `stack[-1] = 1`. `nums[2]` (5) > `nums[1]` (1). Монотонность нарушена!
    *   Это значит, что для элемента с индексом `1` мы нашли его "следующий больший элемент" — это `nums[2]`.
    *   Извлекаем `1` из стека, `result[1] = 5`.
    *   `stack = [0]`. Снова проверяем: `nums[2]` (5) > `nums[0]` (2). Монотонность снова нарушена.
    *   Извлекаем `0` из стека, `result[0] = 5`.
    *   `stack = []`. Стек пуст.
    *   Добавляем текущий индекс `2`.
    *   `stack = [2]` (значение `[5]`)

5.  **Итерация по `nums` (i = 3, val = 6)**:
    *   Смотрим на вершину: `stack[-1] = 2`. `nums[3]` (6) > `nums[2]` (5).
    *   Извлекаем `2`, `result[2] = 6`.
    *   Стек пуст. Добавляем `3`.
    *   `stack = [3]` (значение `[6]`)

6.  **Итерация по `nums` (i = 4, val = 2)**:
    *   Смотрим на вершину: `stack[-1] = 3`. `nums[4]` (2) < `nums[3]` (6). Монотонность не нарушена.
    *   Добавляем `4`.
    *   `stack = [3, 4]` (значения `[6, 2]`)

7.  **Итерация по `nums` (i = 5, val = 3)**:
    *   Смотрим на вершину: `stack[-1] = 4`. `nums[5]` (3) > `nums[4]` (2).
    *   Извлекаем `4`, `result[4] = 3`.
    *   `stack = [3]`. Снова проверяем: `nums[5]` (3) < `nums[3]` (6). Монотонность не нарушена.
    *   Добавляем `5`.
    *   `stack = [3, 5]` (значения `[6, 3]`)

8.  **Конец цикла**: В стеке остались индексы `[3, 5]`. Это означает, что для них "следующий больший элемент" не был найден в массиве. Их результат останется `-1`.

**Итоговый результат**: `[5, 5, 6, -1, 3, -1]`

### Какие проблемы решает монотонный стек?

Этот паттерн эффективно решает задачи, где для каждого элемента массива нужно найти первый элемент справа или слева, который удовлетворяет какому-либо условию (больше, меньше, и т.д.).

Основные типы задач:
1.  **Следующий больший/меньший элемент (Next Greater/Smaller Element)**: Для каждого элемента найти первый элемент справа, который больше/меньше него.
2.  **Предыдущий больший/меньший элемент (Previous Greater/Smaller Element)**: То же самое, но поиск ведется слева. Это достигается простым проходом по массиву в обратном порядке.
3.  **Задачи на диапазоны**: Найти для каждого элемента `nums[i]` такой диапазон `[L, R]`, что `nums[i]` является минимумом или максимумом в этом диапазоне. `L` и `R` как раз и определяются предыдущим/следующим меньшим/большим элементом.
4.  **Задачи с гистограммами**: Классический пример — поиск самого большого прямоугольника в гистограмме.

### Шаблон реализации (Python)

Вот шаблон для поиска **Next Greater Element**. Для **Next Smaller Element** нужно просто поменять знак сравнения `>` на `<`.

```python
def next_greater_element(nums):
    """
    Находит следующий больший элемент для каждого элемента в массиве.
    Использует монотонно убывающий стек.
    """
    n = len(nums)
    result = [-1] * n  # Инициализируем результат значением по умолчанию
    stack = []  # Стек будет хранить ИНДЕКСЫ

    for i in range(n):
        # Пока стек не пуст и текущий элемент больше, чем элемент,
        # на который указывает индекс на вершине стека.
        while stack and nums[i] > nums[stack[-1]]:
            # Индекс на вершине стека нашел свой "Next Greater Element".
            # Это текущий элемент nums[i].
            top_index = stack.pop()
            result[top_index] = nums[i]
        
        # Добавляем текущий индекс в стек для будущего поиска.
        stack.append(i)

    return result

# Пример
nums = [2, 1, 5, 6, 2, 3]
print(f"Массив: {nums}")
print(f"Результат: {next_greater_element(nums)}")
# Вывод:
# Массив: [2, 1, 5, 6, 2, 3]
# Результат: [5, 5, 6, -1, 3, -1]
```

### Анализ сложности

*   **Временная сложность**: `O(N)`, где `N` — количество элементов в массиве. Хотя внутри цикла `for` есть цикл `while`, каждый элемент добавляется в стек и извлекается из него не более одного раза. Поэтому общее количество операций пропорционально `N`.
*   **Пространственная сложность**: `O(N)` в худшем случае. Если массив отсортирован по убыванию (например, `[5, 4, 3, 2, 1]`), то все его индексы будут добавлены в стек.

---

### Популярные задачи на LeetCode

#### 1. [496. Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/)

**Суть**: Даны два массива `nums1` и `nums2`. Для каждого элемента из `nums1` нужно найти его "следующий больший элемент" в `nums2`.

**Решение**:
1.  С помощью монотонного стека находим "Next Greater Element" для **каждого** элемента в `nums2`.
2.  Сохраняем результаты в хеш-таблицу (словарь) `map`, где `ключ` — элемент из `nums2`, а `значение` — его следующий больший элемент.
3.  Проходим по `nums1` и для каждого элемента ищем его значение в `map`.

```python
def nextGreaterElement(nums1: list[int], nums2: list[int]) -> list[int]:
    nge_map = {}
    stack = []
    
    # Шаг 1 и 2: Вычисляем NGE для nums2 и сохраняем в map
    for num in nums2:
        while stack and num > stack[-1]:
            nge_map[stack.pop()] = num
        stack.append(num)
        
    # Для оставшихся в стеке элементов нет NGE
    for num in stack:
        nge_map[num] = -1
        
    # Шаг 3: Формируем результат для nums1
    result = []
    for num in nums1:
        result.append(nge_map[num])
        
    return result
```

#### 2. [84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)

**Суть**: Дана гистограмма в виде массива целых чисел (высот столбцов). Найти площадь самого большого прямоугольника, который можно вписать в эту гистограмму.

**Решение**:
Ключевая идея: для каждого столбца `h = heights[i]`, мы хотим найти максимальную ширину прямоугольника, где `h` является **самым низким** столбцом. Эта ширина определяется первым столбцом слева, который ниже `h`, и первым столбцом справа, который ниже `h`.
Это классическая задача на **Previous Smaller Element** и **Next Smaller Element**.

1.  Проходим по массиву `heights` и с помощью монотонного (возрастающего) стека находим для каждого столбца `i` его следующий меньший элемент `next_smaller[i]` и предыдущий меньший `prev_smaller[i]`.
2.  Для каждого `i` ширина прямоугольника будет `width = next_smaller[i] - prev_smaller[i] - 1`.
3.  Площадь `area = heights[i] * width`.
4.  Находим максимум среди всех таких площадей.

```python
def largestRectangleArea(heights: list[int]) -> int:
    stack = [-1]  # Стек для индексов, -1 как барьер слева
    max_area = 0
    
    for i, h in enumerate(heights):
        # Используем монотонно возрастающий стек
        while stack[-1] != -1 and h < heights[stack[-1]]:
            # Текущий столбец h является "next smaller" для столбца на вершине стека
            current_height = heights[stack.pop()]
            # "previous smaller" - это новый элемент на вершине стека
            current_width = i - stack[-1] - 1
            max_area = max(max_area, current_height * current_width)
        stack.append(i)
        
    # Обрабатываем оставшиеся в стеке столбцы
    # Для них "next smaller" находится за пределами массива
    while stack[-1] != -1:
        current_height = heights[stack.pop()]
        current_width = len(heights) - stack[-1] - 1
        max_area = max(max_area, current_height * current_width)
        
    return max_area
```

#### 3. [739. Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)

**Суть**: Дан массив температур. Для каждого дня нужно найти, через сколько дней наступит более тёплая погода. Если такого дня нет, ответ 0.

**Решение**:
Это прямая адаптация задачи "Next Greater Element". Мы ищем для каждой температуры `T[i]` следующую температуру `T[j]` (где `j > i`), которая выше. Результатом будет разница `j - i`.

```python
def dailyTemperatures(temperatures: list[int]) -> list[int]:
    n = len(temperatures)
    result = [0] * n
    stack = []  # Стек для индексов

    for i in range(n):
        while stack and temperatures[i] > temperatures[stack[-1]]:
            prev_index = stack.pop()
            result[prev_index] = i - prev_index
        stack.append(i)
        
    return result
```

#### 4. [901. Online Stock Span](https://leetcode.com/problems/online-stock-span/)

**Суть**: Нужно реализовать класс, который собирает котировки акций и для каждой новой цены вычисляет "промежуток" (span) — максимальное количество **подряд** идущих дней (включая текущий), в течение которых цена была меньше или равна сегодняшней.

**Решение**:
Это задача на "Previous Greater Element" в "онлайн" режиме. Нам нужно найти первый день слева, когда цена была **выше** текущей. Монотонный (убывающий) стек идеально подходит. В стеке будем хранить пары `(цена, промежуток)`.

```python
class StockSpanner:
    def __init__(self):
        # Стек будет хранить пары (цена, промежуток)
        self.stack = []

    def next(self, price: int) -> int:
        span = 1
        # Пока стек не пуст и цена на вершине <= текущей
        while self.stack and self.stack[-1][0] <= price:
            # Добавляем к текущему промежутку промежуток предыдущего элемента
            span += self.stack.pop()[1]
        
        self.stack.append((price, span))
        return span
```

##### 7. Top K Elements (Топ-K элементов)

Конечно, вот подробный разбор паттерна "Топ K элементов" в формате Markdown.

# Паттерн "Топ K элементов" (Top 'K' Elements)

## Что это за паттерн?

**Топ K элементов** — это алгоритмический паттерн, который используется для эффективного нахождения `K` самых больших, самых маленьких, самых частых или "лучших" по какому-либо критерию элементов из большой коллекции данных.

Ключевая идея паттерна — **избежать полной сортировки всей коллекции**. Сортировка всего массива (сложность O(N log N)) часто избыточна, если нам нужна лишь небольшая его часть (первые `K` элементов). Паттерн "Топ K" позволяет достичь этой цели с лучшей временной сложностью, обычно **O(N log K)**.

## Основная идея и структура данных

Центральным элементом этого паттерна является **куча (Heap)**, также известная как **приоритетная очередь (Priority Queue)**. Куча — это древовидная структура данных, которая позволяет очень быстро (за O(log K)) добавлять элементы и извлекать самый большой или самый маленький элемент (за O(1) для просмотра, O(log K) для извлечения).

Существует два типа куч:
1.  **Min-Heap (Минимальная куча):** Корень всегда является наименьшим элементом.
2.  **Max-Heap (Максимальная куча):** Корень всегда является наибольшим элементом.

### Как это работает?

*   **Для поиска K самых больших элементов** используется **Min-Heap** размером `K`.
    1.  Мы итерируемся по всем элементам коллекции.
    2.  Первые `K` элементов мы просто добавляем в Min-Heap.
    3.  Для каждого следующего элемента (`(K+1)-го` и далее) мы сравниваем его с корнем кучи (самым маленьким из `K` уже отобранных).
    4.  Если новый элемент **больше**, чем корень, мы удаляем корень и вставляем новый элемент. Таким образом, в куче всегда остаются `K` самых больших из уже просмотренных элементов.
    5.  Если новый элемент меньше или равен корню, мы его игнорируем.

*   **Для поиска K самых маленьких элементов** используется **Max-Heap** размером `K` (логика симметрична).

## Какие проблемы решает?

Этот паттерн идеально подходит для решения следующих задач:
*   Найти `K` самых больших или самых маленьких элементов в массиве.
*   Найти `K` самых часто встречающихся элементов.
*   Найти `K` ближайших точек к заданным координатам.
*   Реализовать эффективное слияние `K` отсортированных списков.
*   Решать задачи на планирование (например, выполнить `K` самых прибыльных заданий).
*   Находить медиану в потоке данных.

## Преимущества

*   **Временная сложность:** **O(N log K)**. Это значительно быстрее, чем полная сортировка **O(N log N)**, особенно когда `K` намного меньше `N`.
*   **Пространственная сложность:** **O(K)** для хранения кучи. Это очень эффективно по памяти, если коллекция `N` огромна, а `K` — маленькое.
*   **Работа с потоковыми данными:** Паттерн отлично подходит для обработки данных в режиме реального времени (стриминг), когда мы не можем хранить всю коллекцию в памяти.

## Шаблон реализации (Python)

В Python модуль `heapq` реализует Min-Heap. Чтобы симулировать Max-Heap, можно хранить в куче отрицательные значения чисел.

```python
import heapq

# Шаблон для поиска K самых больших элементов
def find_top_k_largest(nums, k):
    min_heap = []
    for num in nums:
        if len(min_heap) < k:
            heapq.heappush(min_heap, num)
        elif num > min_heap[0]: # Сравнение с наименьшим в куче
            heapq.heapreplace(min_heap, num) # Эффективная замена
    return min_heap

# Шаблон для поиска K самых маленьких элементов
def find_top_k_smallest(nums, k):
    max_heap = []
    for num in nums:
        # Используем отрицательные числа для симуляции Max-Heap
        if len(max_heap) < k:
            heapq.heappush(max_heap, -num)
        elif -num > max_heap[0]: # Сравнение с наибольшим в куче (он самый маленький по модулю)
            heapq.heapreplace(max_heap, -num)
    
    # Возвращаем положительные значения
    return [-x for x in max_heap]
```

## Популярные задачи на LeetCode

### 1. Kth Largest Element in an Array (LeetCode 215)
**Задача:** Найти k-ый по величине элемент в неотсортированном массиве.

```python
import heapq

def findKthLargest(nums: list[int], k: int) -> int:
    # Мы ищем K-ый самый большой. Это то же самое, что найти
    # самый маленький элемент в куче из K самых больших элементов.
    min_heap = []
    for num in nums:
        if len(min_heap) < k:
            heapq.heappush(min_heap, num)
        elif num > min_heap[0]:
            heapq.heapreplace(min_heap, num)
    
    # Корень кучи и есть наш ответ
    return min_heap[0]
```

### 2. Top K Frequent Elements (LeetCode 347)
**Задача:** Найти `K` самых часто встречающихся элементов.

```python
import heapq
from collections import Counter

def topKFrequent(nums: list[int], k: int) -> list[int]:
    # 1. Считаем частоты всех элементов
    freq_map = Counter(nums)
    
    # 2. Используем Min-Heap для хранения K самых частых элементов.
    # В куче будем хранить кортежи (частота, элемент)
    min_heap = []
    for num, freq in freq_map.items():
        if len(min_heap) < k:
            heapq.heappush(min_heap, (freq, num))
        elif freq > min_heap[0][0]:
            heapq.heapreplace(min_heap, (freq, num))
            
    # 3. Извлекаем элементы из кучи
    return [num for freq, num in min_heap]
```

### 3. K Closest Points to Origin (LeetCode 973)
**Задача:** Найти `K` точек, ближайших к началу координат (0, 0).

```python
import heapq
import math

def kClosest(points: list[list[int]], k: int) -> list[list[int]]:
    # Используем Max-Heap, чтобы хранить K точек с наименьшими расстояниями.
    # В куче будем хранить (-расстояние, x, y)
    max_heap = []
    
    for x, y in points:
        # Расстояние в квадрате, чтобы избежать вычисления корня
        dist_sq = x*x + y*y
        if len(max_heap) < k:
            heapq.heappush(max_heap, (-dist_sq, x, y))
        elif -dist_sq > max_heap[0][0]: # Сравниваем с наибольшим расстоянием в куче
            heapq.heapreplace(max_heap, (-dist_sq, x, y))
            
    # Извлекаем точки из кучи
    return [[x, y] for dist, x, y in max_heap]
```

### 4. Merge k Sorted Lists (LeetCode 23)
**Задача:** Слить `K` отсортированных связанных списков в один.

```python
import heapq

# Определение узла списка (для контекста)
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

def mergeKLists(lists: list[Optional[ListNode]]) -> Optional[ListNode]:
    # Min-Heap будет хранить кортежи (значение, индекс_списка, узел)
    min_heap = []
    for i, l in enumerate(lists):
        if l:
            # Добавляем id списка, чтобы избежать ошибки сравнения узлов с одинаковыми значениями
            heapq.heappush(min_heap, (l.val, i, l))
    
    dummy_head = ListNode()
    current = dummy_head
    
    while min_heap:
        val, i, node = heapq.heappop(min_heap)
        
        # Добавляем узел в результирующий список
        current.next = node
        current = current.next
        
        # Если в исходном списке есть еще узлы, добавляем следующий в кучу
        if node.next:
            heapq.heappush(min_heap, (node.next.val, i, node.next))
            
    return dummy_head.next
```

## Когда использовать паттерн "Топ K"? (Сигналы)

Ищите этот паттерн, если в условии задачи есть следующие признаки:

*   **Ключевые слова:** "top K", "K-й самый большой/маленький", "K самых частых", "K ближайших", "K самых дорогих".
*   **Входные данные:** Большая, как правило, неотсортированная коллекция (массив, список).
*   **Требование:** Нужно найти подмножество элементов, отсортированное по какому-либо критерию, но не всю коллекцию.
*   **Ограничения:** `K` значительно меньше, чем общее количество элементов `N`.

## Сравнение с другими подходами

| Подход | Временная сложность | Пространственная сложность | Когда использовать |
| :--- | :--- | :--- | :--- |
| **Куча (Heap)** | O(N log K) | O(K) | Лучший универсальный вариант, идеален для стриминга. |
| **Полная сортировка** | O(N log N) | O(1) или O(N) | Когда `K` близко к `N` или когда нужна вся отсортированная коллекция. |
| **Quickselect** | O(N) в среднем, O(N²) в худшем | O(1) | Когда нужно найти **только один** K-й элемент, а не все `K` элементов. |

##### 8. Overlapping Intervals (Перекрывающиеся интервалы)

##### 9. Modified Binary Search (Модифицированный бинарный поиск)

##### 10. Binary Tree Traversal (Обход бинарного дерева)

##### 11. Backtracking (Поиск с возвратом)

##### 12. Dynamic Programming (Динамическое программирование)

##### 13. Graph Traversal (Обход графа)

##### 14. Topological Sort (Топологическая сортировка)

##### 15. Union Find (Объединение и поиск)
