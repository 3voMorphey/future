# Паттерн Outbox: Гарантированная доставка сообщений

**Outbox** — это паттерн проектирования, используемый в распределенных системах (особенно в микросервисной архитектуре) для надежной и отказоустойчивой отправки сообщений в брокеры сообщений (такие как RabbitMQ, Kafka, SQS и др.). Его главная задача — решить проблему **двойной записи (dual-write)** и обеспечить атомарность между изменением состояния в базе данных и отправкой связанного с этим изменением события.

### 1. Проблема: Атомарность между базой данных и брокером сообщений

Представьте типичную ситуацию в микросервисе. Сервис заказов должен сохранить новый заказ в свою базу данных и уведомить другие сервисы (например, сервис доставки и сервис уведомлений) о том, что заказ создан.

Наивный подход выглядит так:

```
// Псевдокод
function createOrder(orderData) {
    // Шаг 1: Начать транзакцию в БД
    DB.beginTransaction();
    try {
        // Сохранить заказ в базе данных
        const newOrder = DB.insert("orders", orderData);
        // Завершить транзакцию
        DB.commit();
    } catch (error) {
        DB.rollback();
        throw error;
    }

    // ---- ТОЧКА СБОЯ ----
    // Если приложение "упадет" здесь, заказ будет в БД,
    // но сообщение никогда не будет отправлено.
    // Система становится НЕКОНСИСТЕНТНОЙ.

    // Шаг 2: Отправить сообщение в брокер
    try {
        messageBroker.publish("order.created", { orderId: newOrder.id, ... });
    } catch (error) {
        // Что делать здесь?
        // Повторить отправку? А если сообщение отправилось, но мы не получили подтверждение?
        // Удалить заказ из БД? Это сложно и неправильно.
    }
}
```

Этот подход порождает две критические проблемы:

1.  **Сбой после коммита в БД, но до отправки в брокер**: Состояние в базе данных изменилось (заказ создан), но сообщение не было отправлено. Другие сервисы никогда не узнают о новом заказе. Данные в системе становятся несогласованными.
2.  **Сбой во время отправки в брокер**: Брокер может быть временно недоступен. Если мы повторим операцию, есть риск отправить дубликат сообщения.

Проблема в том, что **транзакция базы данных и отправка сообщения в брокер не являются атомарной операцией**. Нельзя обернуть их в одну общую транзакцию.

### 2. Решение: Паттерн Outbox

Идея паттерна Outbox проста: вместо того чтобы напрямую отправлять сообщение в брокер, мы сохраняем его в специальную таблицу `outbox` в **той же самой транзакции базы данных**, в которой мы изменяем бизнес-сущность.

Таким образом, операция становится атомарной на уровне базы данных: либо и бизнес-данные, и "сообщение на отправку" успешно сохраняются, либо (в случае сбоя) откатываются вместе.

#### Схема работы паттерна:


1.  **Сервис (Издатель)**: Выполняет бизнес-логику.
2.  **Транзакция БД**: В рамках одной атомарной транзакции происходят два действия:
    *   Изменение бизнес-данных (например, `INSERT` в таблицу `orders`).
    *   Создание записи в таблице `outbox` с деталями сообщения.
3.  **Message Relay**: Отдельный, асинхронный процесс или поток, который следит за таблицей `outbox`.
4.  **Брокер сообщений**: Получает сообщения от "Message Relay".

### 3. Как это работает: Компоненты и шаги

#### Шаг 1: Атомарная запись

Когда сервис выполняет бизнес-операцию, он делает это в одной транзакции.

```sql
-- Пример транзакции для создания заказа
BEGIN;

-- 1. Вставляем запись в основную бизнес-таблицу
INSERT INTO orders (id, user_id, total_amount, status)
VALUES ('order-123', 'user-abc', 99.99, 'CREATED');

-- 2. Вставляем запись в таблицу outbox
INSERT INTO outbox (id, aggregate_id, aggregate_type, event_type, payload)
VALUES (
    'event-456',
    'order-123',          -- ID связанной сущности
    'Order',              -- Тип сущности
    'OrderCreated',       -- Тип события
    '{"userId": "user-abc", "items": [...]}' -- Тело сообщения (payload)
);

COMMIT;
```

#### Таблица `outbox`

Структура этой таблицы может варьироваться, но обычно она содержит:
*   `id`: Уникальный идентификатор события (UUID).
*   `aggregate_type`: Тип бизнес-сущности, с которой связано событие (например, "Order", "User").
*   `aggregate_id`: Идентификатор конкретного экземпляра сущности (например, ID заказа).
*   `event_type`: Тип события для маршрутизации (например, "OrderCreated", "OrderShipped").
*   `payload`: Тело сообщения в формате JSON или другом сериализованном виде.
*   `created_at`: Временная метка создания.
*   `processed_at`: Временная метка, когда сообщение было успешно отправлено (изначально `NULL`).

#### Шаг 2: Асинхронный "Message Relay"

Это независимый компонент, который отвечает за фактическую доставку сообщений. Его задача — периодически проверять таблицу `outbox` на наличие необработанных записей, отправлять их в брокер и помечать как обработанные.

Существует два основных способа реализации "Message Relay":

### 4. Способы реализации Message Relay

#### 4.1. Polling Publisher (Опрашивающий издатель)

Это самый простой способ. Отдельный фоновый процесс (background worker/job) с определенной периодичностью (например, каждые 100 мс) выполняет следующие действия:

1.  Запрашивает из таблицы `outbox` записи, где `processed_at IS NULL`.
    ```sql
    SELECT * FROM outbox WHERE processed_at IS NULL ORDER BY created_at LIMIT 100;
    ```
2.  Для каждой полученной записи пытается отправить ее в брокер сообщений.
3.  Если отправка прошла успешно:
    *   Обновляет запись в `outbox`, устанавливая `processed_at`, или просто удаляет её.
    ```sql
    UPDATE outbox SET processed_at = NOW() WHERE id = '...';
    -- или
    DELETE FROM outbox WHERE id = '...';
    ```

*   **Преимущества**:
    *   Простота реализации. Не требует сложной инфраструктуры.
*   **Недостатки**:
    *   **Задержка**: Сообщения отправляются не мгновенно, а с задержкой, равной интервалу опроса.
    *   **Нагрузка на БД**: Постоянные запросы `SELECT` могут создавать ненужную нагрузку на базу данных.

#### 4.2. Transaction Log Tailing (Чтение лога транзакций, CDC)

Это более продвинутый и эффективный подход, основанный на **Change Data Capture (CDC)**.

Почти все современные реляционные СУБД (PostgreSQL, MySQL, SQL Server) ведут **журнал предзаписи (Write-Ahead Log, WAL)** или лог транзакций. Этот лог содержит все изменения, происходящие в базе данных.

Специализированные инструменты (например, **Debezium**, Maxwell's Daemon) могут "слушать" этот лог, и как только в нем появляется запись о вставке в таблицу `outbox`, они мгновенно считывают её и пересылают в брокер сообщений (чаще всего, в Kafka).

*   **Преимущества**:
    *   **Низкая задержка**: Сообщения отправляются практически в реальном времени.
    *   **Низкая нагрузка на БД**: Не требуется выполнять постоянные `SELECT` запросы. Сервис-издатель вообще не знает о процессе отправки.
*   **Недостатки**:
    *   **Сложность**: Требует развертывания и настройки дополнительной инфраструктуры (Debezium, Kafka Connect и т.д.).

### 5. Преимущества и недостатки паттерна Outbox

#### ✅ Преимущества

1.  **Надежность и согласованность данных**: Гарантирует, что ни одно событие не будет потеряно, если приложение упадет. Решает проблему двойной записи.
2.  **Атомарность**: Обеспечивает атомарность между сохранением состояния и "намерением" отправить событие.
3.  **Разделение ответственности (Separation of Concerns)**: Бизнес-логика сервиса не занимается деталями отправки сообщений, отказоустойчивостью и повторными попытками.

#### ❌ Недостатки

1.  **Увеличенная задержка**: Сообщения доставляются не мгновенно, а с небольшой задержкой (особенно при использовании polling-подхода).
2.  **Потенциальные дубликаты (At-Least-Once Delivery)**: Если "Message Relay" отправит сообщение, но упадет до того, как пометит его как обработанное, он отправит его повторно после перезапуска. Это означает, что система гарантирует доставку **как минимум один раз (at-least-once)**. Сервисы-потребители **должны быть идемпотентными** (способными безопасно обрабатывать дубликаты сообщений).
3.  **Усложнение**: Требует создания дополнительной таблицы и отдельного процесса для отправки сообщений.
4.  **Порядок сообщений**: Гарантировать строгий порядок сообщений может быть сложно, особенно если у вас несколько экземпляров "Message Relay". Обычно порядок гарантируется в пределах одной сущности (`aggregate_id`).

### 6. Итог и когда использовать

Паттерн **Outbox** является промышленным стандартом для обеспечения надежной коммуникации между микросервисами.

**Используйте его, когда:**

*   Надежность и согласованность данных критически важны.
*   Вы работаете в микросервисной архитектуре и хотите избежать распределенных транзакций (которые сложны и плохо масштабируются).
*   Потеря сообщения в результате сбоя недопустима для вашего бизнеса (например, в системах обработки заказов, финансовых транзакциях, управлении запасами).

Это небольшая плата в виде усложнения архитектуры за огромный выигрыш в надежности и отказоустойчивости вашей распределенной системы.

--- 

##### Прочее
- [Transactional Outbox: от идеи до open-source](https://habr.com/ru/companies/kuper/articles/819803/)
- [Паттерн Outbox](https://nikolaymatrosov.ru/2024-02-18-Transactional-outbox-pattern/)
- [Паттерн Outbox: как не растерять сообщения в микросервисной архитектуре](https://habr.com/ru/companies/lamoda/articles/678932/)


